# Урок 8. Мой таймер

## Теория

Таймер — это устройство, которое отсчитывает заданный интервал времени и сообщает о его завершении.  
В микроконтроллерах есть два основных подхода к созданию таймера:

1) **Блокирующий** (на `delay()`): просто «замораживает» выполнение программы на заданное время.  
2) **Неблокирующий** (на `millis()`): программа продолжает работать параллельно (можно обрабатывать кнопки, мигать светодиодом, считать секунды и т.п.).

В реальных проектах почти всегда полезнее второй способ: он позволяет сделать **старт/стоп/сброс**, «подсветку» оставшегося времени, работу с несколькими устройствами одновременно.

---

## Интересные факты

- Первые механические кухонные таймеры с часовой пружиной появились в начале XX века.  
- Помодоро‑таймер (25 минут работы + 5 минут отдыха) предложил Франческо Чирилло в конце 1980‑х как технику продуктивности.  
- В электронике неблокирующая работа с временем — ключ к «многозадачности» на простом контроллере без операционной системы.

---

## Практика

Соберём простой **личный таймер** со следующим поведением:

- Короткое нажатие кнопки — **переключение предустановок** длительности (10 с → 30 с → 60 с → 120 с → … по кругу).  
- Долгое нажатие (≥1 с) — **старт/стоп** отсчёта.  
- По завершении — **сигнал**: мигающий светодиод и/или писк пьезо‑динамика (если есть).

### Материалы

- Arduino Uno (или совместимая плата)  
- Светодиод + резистор 220 Ω  
- Кнопка + резистор 10 кΩ (pull‑down) *или* использовать внутренний `INPUT_PULLUP`  
- Пьезо‑динамик (опционально)  
- Макетная плата, провода

> Если нет пьезо‑динамика — оставьте только световой сигнал.

### Подключение (вариант с внешним pull‑down)

- **LED**: анод через 220 Ω → D13, катод → GND  
- **Кнопка**: один вывод → D2, второй → GND; между D2 и GND — резистор 10 кΩ  
- **Пьезо** (опционально): один вывод → D8, второй → GND

---

## Программный код (неблокирующий таймер на `millis()` с пресетами и долгим нажатием)

```cpp
// Урок 8: Мой таймер (millis, пресеты, короткое/долгое нажатие, сигнал по завершении)

const int LED_PIN    = 13;
const int BTN_PIN    = 2;
const int BUZZER_PIN = 8;   // опционально; если нет динамика — не используйте tone()

// Предустановки длительности таймера (в миллисекундах)
unsigned long presets[] = {10000UL, 30000UL, 60000UL, 120000UL}; // 10с, 30с, 60с, 120с
int presetIndex = 0;

bool running = false;              // идёт ли отсчёт
unsigned long tStart = 0;          // момент старта
unsigned long tRemain = 0;         // оставшееся время (для паузы/возобновления)

unsigned long lastBtnChange = 0;   // для антидребезга
bool lastBtnState = HIGH;          // используем INPUT_PULLUP ниже
const unsigned long DEBOUNCE_MS = 30;

unsigned long pressStart = 0;
bool longPressHandled = false;
const unsigned long LONG_PRESS_MS = 1000;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(BTN_PIN, INPUT_PULLUP); // кнопка к GND, логика инвертирована
  pinMode(BUZZER_PIN, OUTPUT);
  Serial.begin(9600);
  printStatus();
}

void loop() {
  handleButton();
  updateTimer();
}

// --- Обработка кнопки: короткое нажатие -> смена пресета; долгий клик -> старт/стоп
void handleButton() {
  bool raw = digitalRead(BTN_PIN);
  unsigned long now = millis();

  // антидребезг
  if (raw != lastBtnState && (now - lastBtnChange) > DEBOUNCE_MS) {
    lastBtnChange = now;
    lastBtnState = raw;

    // нажатие (переход HIGH->LOW из-за INPUT_PULLUP)
    if (raw == LOW) {
      pressStart = now;
      longPressHandled = false;
    } else { // отпускание (LOW->HIGH)
      unsigned long pressDur = now - pressStart;

      if (!longPressHandled) {
        if (pressDur < LONG_PRESS_MS) {
          // короткое нажатие: переключить пресет, если таймер не бежит
          if (!running) {
            presetIndex = (presetIndex + 1) % (sizeof(presets)/sizeof(presets[0]));
            tRemain = presets[presetIndex];
            blinkOnce(); // визуальная обратная связь
            printStatus();
          }
        }
      }
    }
  }

  // обрабатываем долгий клик, пока кнопка удерживается
  if (lastBtnState == LOW && !longPressHandled && (now - pressStart) >= LONG_PRESS_MS) {
    longPressHandled = true;
    toggleStartStop();
  }
}

void toggleStartStop() {
  if (!running) {
    // старт
    running = true;
    if (tRemain == 0) tRemain = presets[presetIndex];
    tStart = millis();
    Serial.println("Старт отсчёта");
  } else {
    // стоп/пауза
    running = false;
    unsigned long elapsed = millis() - tStart;
    if (elapsed < tRemain) {
      tRemain -= elapsed; // сохраним остаток
    } else {
      tRemain = 0;
    }
    Serial.println("Пауза");
  }
  digitalWrite(LED_PIN, LOW);
  noTone(BUZZER_PIN);
  printStatus();
}

void updateTimer() {
  if (!running) return;

  unsigned long now = millis();
  unsigned long elapsed = now - tStart;

  if (elapsed >= tRemain) {
    // Время вышло!
    running = false;
    tRemain = 0;
    alarmSignal();      // сигнализация завершения
    Serial.println("Готово! Таймер завершён.");
    printStatus();
  } else {
    // простая световая «анимация» каждые 500 мс во время отсчёта
    if ((now / 500) % 2 == 0) digitalWrite(LED_PIN, HIGH);
    else                      digitalWrite(LED_PIN, LOW);
  }
}

void alarmSignal() {
  // 5 вспышек + писк
  for (int i = 0; i < 5; i++) {
    digitalWrite(LED_PIN, HIGH);
    tone(BUZZER_PIN, 880);  // А5
    delay(120);
    digitalWrite(LED_PIN, LOW);
    noTone(BUZZER_PIN);
    delay(120);
  }
}

void blinkOnce() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
}

void printStatus() {
  Serial.print("Пресет: ");
  Serial.print(presets[presetIndex] / 1000);
  Serial.print(" c | Остаток: ");
  Serial.print(tRemain / 1000.0, 1);
  Serial.print(" c | Состояние: ");
  Serial.println(running ? "идёт" : "стоп");
}
```

Эксперименты

Добавьте пресеты 5 мин и 15 мин; сделайте индикатор: короткая вспышка LED = переключение пресета.
Измените сигнал по завершении: длинный писк + быстрое мигание 1 секунду.
Индикация хода: каждую секунду печатайте в Serial оставшееся время в формате ММ:СС.
Тихий режим: по долгому нажатию перед стартом включайте/отключайте звук (флаг в коде).
Кнопка СБРОС: добавьте вторую кнопку — мгновенно останавливает и возвращает текущий пресет.

Задание для самостоятельной работы

Схема: зарисуйте подключение для варианта с INPUT_PULLUP (кнопка → GND).
Таблица тестов: проверьте все пресеты (10, 30, 60, 120 с) — зафиксируйте фактическое время по секундомеру и погрешность.
Интервальный таймер: реализуйте режим «работа‑отдых» (например, 20 с работы, 10 с отдыха, 8 циклов).
Потенциометр (если есть): добавьте возможность задавать длительность ручкой от 5 до 120 с (analogRead → map).
Помодоро: 25 мин работы и 5 мин отдыха, 4 повтора; разный сигнал окончания «работы» и «отдыха».
