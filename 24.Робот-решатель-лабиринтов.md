# Урок 24. Робот-решатель лабиринтов

## Теория  

Робот-решатель лабиринтов (Line Follower / Maze Solver) — это мобильная платформа, которая может самостоятельно пройти через лабиринт.  
Принцип работы:  
1. На полу нарисован лабиринт (обычно чёрная линия на белой поверхности).  
2. Робот использует **ИК-датчики линии**, чтобы различать чёрное и белое.  
3. Arduino принимает решение: двигаться прямо, повернуть налево или направо.  

В простейшем варианте робот следует по линии. В более сложном — запоминает повороты, строит карту и ищет кратчайший путь.  

---

## Интересные факты  

- Первые роботы для соревнований Line Follower появились в Японии в 1977 году.  
- В соревнованиях Maze Solver роботы должны не только проехать лабиринт, но и оптимизировать маршрут.  
- Алгоритм **левостороннего правила** или **правостороннего правила** (всегда держаться одной стены) позволяет пройти большинство лабиринтов.  
- В индустрии похожие алгоритмы применяются в системах AGV (автоматизированных тележках на складах).  

---

## Практика  

### Материалы  

- Arduino Uno (или совместимая).  
- Шасси 2WD (2 колеса + моторы).  
- Драйвер моторов L298N или L293D.  
- 2–3 ИК-датчика линии (модули TCRT5000 или QTR).  
- Батарейный блок.  
- Макет лабиринта (чёрная изолента на белом картоне).  

---

### Подключение (пример с 2 датчиками)  

- Датчик линии левый → D2.  
- Датчик линии правый → D3.  
- Драйвер моторов:  
  - IN1, IN2 → D8, D9 (левый мотор).  
  - IN3, IN4 → D10, D11 (правый мотор).  
  - ENA, ENB → D5, D6 (PWM).  

---

## Программный код (простой Line Follower)

```cpp
// Урок 24: Робот-решатель лабиринтов (простая версия)
// Два ИК-датчика: если оба на белом — едем вперёд,
// если левый на линии — поворот влево, если правый — вправо.

int leftSensor = 2;
int rightSensor = 3;

int IN1 = 8;
int IN2 = 9;
int IN3 = 10;
int IN4 = 11;

void setup() {
  pinMode(leftSensor, INPUT);
  pinMode(rightSensor, INPUT);

  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
}

void loop() {
  int left = digitalRead(leftSensor);
  int right = digitalRead(rightSensor);

  if (left == HIGH && right == HIGH) {
    forward();
  } else if (left == LOW && right == HIGH) {
    leftTurn();
  } else if (left == HIGH && right == LOW) {
    rightTurn();
  } else {
    stopRobot();
  }
}

void forward() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void leftTurn() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void rightTurn() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void stopRobot() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

```

Программный код (алгоритм «держись правой стены» для лабиринта)

```cpp
// Урок 24: Робот-решатель лабиринтов (правило правой стены)
// Требуются 3 датчика: левый, центральный, правый

int leftSensor = 2;
int midSensor = 3;
int rightSensor = 4;

int IN1 = 8;
int IN2 = 9;
int IN3 = 10;
int IN4 = 11;

void setup() {
  pinMode(leftSensor, INPUT);
  pinMode(midSensor, INPUT);
  pinMode(rightSensor, INPUT);

  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
}

void loop() {
  int left = digitalRead(leftSensor);
  int mid = digitalRead(midSensor);
  int right = digitalRead(rightSensor);

  if (right == HIGH) {
    rightTurn();
  } else if (mid == HIGH) {
    forward();
  } else if (left == HIGH) {
    leftTurn();
  } else {
    stopRobot();
  }
}

void forward() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void leftTurn() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void rightTurn() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void stopRobot() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

```

Эксперименты

Попробуйте увеличить количество датчиков (3–5), чтобы робот лучше ориентировался.
Измените скорость моторов через PWM (например, analogWrite(ENA, 150);).
Сделайте развилки и проверьте, как робот ведёт себя при выборе пути.
Попробуйте реализовать правило «держись левой стены».
Сделайте «режим обучения»: робот запоминает последовательность поворотов, а потом воспроизводит её.

Задание для самостоятельной работы

Нарисуйте схему подключения робота-лабиринтника.
Составьте таблицу: комбинация датчиков → действие (вперёд, влево, вправо, стоп).
Добавьте звуковой сигнал: при остановке робот подаёт писк.
Реализуйте счётчик пройденных перекрёстков (выводите в Serial Monitor).
Сделайте проект «соревнования»: два робота проходят одинаковый лабиринт и соревнуются по скорости.
